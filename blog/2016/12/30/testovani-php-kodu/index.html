<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <meta name="description" content="Oficiální stránky PHP komunity">
    <meta name="keywords" content="PHP, komunita, programování">
    <meta name="author" content="https://pehapkari.cz">
    <meta name="robots" content="index, follow">

    <meta property="og:image" content="/images/php-square.png">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <link rel="alternate" type="application/rss+xml" title="Péhápkaři.cz Blog RSS" href="/rss.xml">

    <link href="/assets/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <link href="/assets/bootstrap/bootstrap.min.css?v=0.6" rel="stylesheet" type="text/css">

    <link href="/assets/css/style.css?v=0.6" rel="stylesheet" type="text/css">

    <link href="/favicon.ico" rel="shortcut icon">

    <title>Testování PHP kódu</title>
</head>

    <body>
<header>
    <div class="hidden-sm-down">
        <div class="container-fluid">
            <a href="/"><img src="/assets/images/logo-header.svg?ver" alt="" height="50"></a>

            <nav class="navbar top-navigation">
                <a href="/blog/" class="active">
                    <em class="fa fa-newspaper-o fa-fw"></em>
                    Blog
                </a>
                <a href="/vzdelavej-se/">
                    <em class="fa fa-graduation-cap fa-fw"></em>
                    Školení
                </a>
                <a href="/mentori/">
                    <em class="fa fa-handshake-o fa-fw"></em>
                    Mentoři
                </a>

                    

                    <a href="https://github.com/pehapkari/pehapkari.cz/edit/master/source/_posts/2016/2016-12-30-testovani-php-kodu.md" class="hidden-sm">
                        <em class="fa fa-fw fa-pencil"></em>
                        Edit
                    </a>
            </nav>
        </div>
    </div>

    <div id="mobile-menu" class="row text-center hidden-md-up">
        <div class="container">
            <a href="/" class="col-3 col-sm-3">
                <em class="fa fa-home"></em>
                <br>
                Home
            </a>
            <a href="/blog/" class="col-3 col-sm-3 active">
                <em class="fa fa-book fa-fw"></em>
                <br>
                Blog
            </a>
            <a href="/vzdelavej-se/" class="col-3 col-sm-3">
                <em class="fa fa-graduation-cap fa-fw"></em>
                <br>
                Školení
            </a>
            <a href="/mentori/" class="col-3 col-sm-3">
                <em class="fa fa-handshake-o fa-fw"></em>
                <br>
                Mentoři
            </a>
        </div>
    </div>
</header>

        <div id="article">
            <div class="container">
                <h1 class="h2 text-center">Testování PHP kódu</h1>

                <div class="row text-center">
                    <div class="col-md-12">
<div class="metadataLine">

    <p>
        <em class="fa fa-clock-o fa-fw"></em>
        7 min

        |

        by <strong>Petr Hejna</strong>

        &ndash;

        <time datetime="2016-12-Fri">
            30. 12. 2016
        </time>

    </p>
</div>
                    </div>
                </div>

                <br>

                <div id="article-content">
                    <p class="perex">Testování aplikací není vždy tak snadné, jak se na papíře jeví. Svojí zkušeností jsem dospěl k&nbsp;několika zásadám a&nbsp;postupům, které se mi osvědčily a&nbsp;které se tu pokusím sepsat a&nbsp;částečně i&nbsp;zdůvodnit. Pomáhají mi k&nbsp;psaní čítelnějších a&nbsp;udržovatelnějších testů. Za hlavní přínos pak považuji snadnou rozšiřitelnost testů, jejíž potřeba přichází s&nbsp;rozšiřováním fukcionality projektu.</p>

                    
<h2 id="2-definice-kterych-se-drzim"><a class="anchor" href="#2-definice-kterych-se-drzim" aria-hidden="true"><span class="anchor-icon">#</span></a>2 definice, kterých se držím</h2>
<h3 id="test-je-blok-kodu"><a class="anchor" href="#test-je-blok-kodu" aria-hidden="true"><span class="anchor-icon">#</span></a>Test je blok kódu</h3>
<p>K&nbsp;testu <strong>nepřistupuji jako ke třídě</strong>, k&nbsp;testu <strong>nepřistupuji jako k&nbsp;fukci</strong> K&nbsp;testu přistupuji jako k&nbsp;bloku kódu – <strong>jako ke scriptu</strong>. Následováním tohoto přístupu:</p>
<ul>
<li>redukuji objem kódu v&nbsp;jednom testovacím scénáři (jsem veden vyčlenit si helpery mimo samotný test),</li>
<li>snižuji komplexitu testovacího stacku (jsem veden řešit závislosti správným směrem – jak na to,
se rozepíši později v článku).</li>
</ul>
<h3 id="test-ma-3-slozky"><a class="anchor" href="#test-ma-3-slozky" aria-hidden="true"><span class="anchor-icon">#</span></a>Test má 3 složky</h3>
<p>Neustále si uvědomuji, že test se skládá z</p>
<ul>
<li><strong>definice výchozího stavu</strong></li>
<li><strong>přechodu do jiného stavu</strong></li>
<li>následně <strong>validace konečného stavu</strong></li>
</ul>
<blockquote class="alert alert-warning">
    <p>
        Psaní testů do tříd <code>TestCase</code> tedy považuji jen za <em>syntactic sugar</em> testovacích frameworků,
        což poskytuje jistý komfort (<code>setUp</code>, <code>tearDown</code>, <code>@dataProvider</code>).
    </p>
</blockquote>
<p>Z&nbsp;těchto základů jsem si pak vyvodil několik zásad.</p>
<h2 id="pisi-code-testcase-code-tridy-bezstavove"><a class="anchor" href="#pisi-code-testcase-code-tridy-bezstavove" aria-hidden="true"><span class="anchor-icon">#</span></a>Píši <code>TestCase</code> třídy bezstavově</h2>
<p>Nepíši žádné <code>$this-&gt;someObject</code> s&nbsp;nějakými daty, mocky nebo testovanými subjekty. Vše předávám přes parametry
metod. Přidává to na přehlednosti a&nbsp;čitelnosti, a&nbsp;tak to usnadňuje pozdější rozšiřování testu.</p>
<p><strong>Správně</strong></p>
<ul>
<li>Pro rozšíření testu jen přidám <code>@dataProvider</code>, extrahuji parametr <code>5</code> a očekávanou hodnotu <code>xyz</code>.</li>
<li>Vše co test obsahuje, je na jednom místě. Detaily jsou skryté za voláním metod.</li>
</ul>
<pre><code class="language-php">public function testFoo()  : void
{
    $bar = $this-&gt;createMockBar(5);
    $service = new Service($bar);

    $result = $service-&gt;foo();

    Assert::equals('xyz', $result);
}</code></pre>
<p><strong>Špatně</strong></p>
<ul>
<li>Pro rozšíření testu musím udělat novou třídní proměnnou a zduplikovat kód testu.</li>
<li>V&nbsp;testu není na první pohled patrné, jak je definován počátečná stav.</li>
<li>Motivací bývá většinou snaha o znovupoužitelnost objektu (mocku, služby, <em>value-objectu</em>), avšak není
pro ni žádný důvod. V&nbsp;praxi vůbec ničemu nevadí si pro každý běh testu objekty vytvářet.</li>
</ul>
<pre><code class="language-php">public function setUp(): void
{
    $this-&gt;mockBar = $this-&gt;createMockBar(5);
}

public function testFoo(): void
{
    $service = new Service($this-&gt;mockBar);

    $result = $service-&gt;foo();

    Assert::equals('xyz', $result);
}</code></pre>
<p>Do <code>setUp()</code> dávám věci, které připravují prostředí pro test, například strukturu databáze. Nedávám tam ale už
insert testovacích dat, která jsou specifická pro daný scénář testu. Skryl bych tím totiž definici výchozího
stavu konkrétního scénáře.</p>
<blockquote class="alert alert-info"><p>
    Z těchto principů také přímo vyplývá, že <code>TestCase</code> třída je <em>immutable</em>.
    Protože není co měnit. ;)
</p></blockquote>
<h2 id="peclive-odeluji-casti-testu"><a class="anchor" href="#peclive-odeluji-casti-testu" aria-hidden="true"><span class="anchor-icon">#</span></a>Pečlivě oděluji části testu</h2>
<p>Čím výrazněji jsou od sebe části testu odděleny a&nbsp;čím menší a&nbsp;jednodušší jsou, tím rychleji při čtení
kódu pochopím, co test testuje.</p>
<p>Proto:</p>
<ul>
<li>Vyčlením definici výchozího stavu do <a href="https://phpunit.de/manual/current/en/phpunit-book.html#writing-tests-for-phpunit.data-providers">Data Providerů</a>.</li>
<li>Kód na přípravu stavu rozkouskuji do metod, které případně obalím factory metodou.</li>
<li>Samotný přechod stavu redukuji ideálně jen na volání jediné metody.</li>
<li>Asserty oddělím vizuálně od zbytku prázdným řádkem.</li>
</ul>
<pre><code class="language-php">/**
 * @dataProvider getDataForFooTest
 */
public function testFoo(string $expectdResult, string $valueForFoo, string $valueForBar): void
{
    $bar = $this-&gt;mockBar($valueForBar); // Příprava výchozího stavu
    $foo = $this-&gt;mockFoo($valueForBar);
    $service = new Xyz($foo, $bar);

    $result = $service-&gt;foo(); // Přechod

    Assert::equals('xyz', $result); // Assertace výsledného stavu
}</code></pre>
<h2 id="zavislosti-testovaneho-kodu-a-nbsp-jejich-skladani"><a class="anchor" href="#zavislosti-testovaneho-kodu-a-nbsp-jejich-skladani" aria-hidden="true"><span class="anchor-icon">#</span></a>Závislosti testovaného kódu a&nbsp;jejich skládání</h2>
<p>Když musím kódu, který testuji, dodat nějaké závislosti (často namockované), vždy vytvářím <strong>factory metody</strong>.</p>
<p>Při sestavování závislostí dbám na to, abych praktikoval <em>Dependency Injection</em> skrze parametry factory metody
a&nbsp;aby každá factory metoda vytvářela jen jednu věc.</p>
<p><strong>Správně</strong></p>
<pre><code class="language-php">public function testXyz(string $expected, int $valueForBar): void
{
     // Když budu chtít přidat $valueForBar2, upravím jen jedno místo.
     $bar = $this-&gt;mockBar($valueForBar);
     // Předávám už hotový objekt – tedy celou závislost. Factory metoda
     // pak z vnějšího pohledu dělá jen jednu věc, vytváří mock Foo
     // a je závislá na tom, aby dostala třídu typu Bar.
     $foo = $this-&gt;mockFoo($bar);
     $service = new Xyz($foo);

     $result = $service-&gt;xyz();

     Assert::equals($expected, $result);
}

public function mockFoo(Bar $bar): Foo
{
  return Mockery::mock(Foo::class)-&gt;shouldRecieve('getBar')-&gt;andReturn($bar)-&gt;getMock();
}</code></pre>
<p><strong>Špatně</strong></p>
<pre><code class="language-php">public function testXyz(string $expected, int $valueForBar)
{
     // Předává se pouze hodnota a factory metoda pak dělá dvě věci,
     // z vnějšího pohledu vytváří mock pro Foo i pro Bar.
     $foo = $this-&gt;mockFoo($valueForBar);
     $service = new Xyz($foo);

     $result = $service-&gt;xyz();

     Assert::equals('expected', $result);
}

public function mockFoo(int $valueForBar): Foo
{
    // Když budu chtít přidat $valueForBar2, budu muset upravit všechny metody po cestě.
    $bar = $this-&gt;mockBar($valueForBar);

    return Mockery::mock(Foo::class)-&gt;shouldRecieve('getBar')-&gt;andReturn($bar)-&gt;getMock();
}</code></pre>
<blockquote class="alert alert-info"><p>
    Factory metody nemusí být vůbec definované na <code>TestCase</code> třídě daného testu, ale pokud se jedná o factorky
    určené jen pro konkrétní test, je praktické si je držet na jednom místě. Pokud je ale znovupoužívám,
    extrahuji je do helperů (v PHPUnit do traitů).
</p></blockquote>
<h2 id="kdy-mockuji-a-nbsp-kdy-ne"><a class="anchor" href="#kdy-mockuji-a-nbsp-kdy-ne" aria-hidden="true"><span class="anchor-icon">#</span></a>Kdy mockuji a&nbsp;kdy ne</h2>
<p>Mockovat je drahé. Je drahé mocky psát a&nbsp;je drahé je pak udržovat. Proto většinou nemockuji:</p>
<ul>
<li>value objecty,</li>
<li><em>stateless</em> služby – jejich metody tudíž vždy vracejí pro konkrétní vstup stejný výstup.</li>
</ul>
<p>Naopak mockuji:</p>
<ul>
<li>služby, které sahají na nějaký stav nebo komunikují mimo aplikaci (disk, databáze, api, …),</li>
<li>jakékoliv objekty, které mají složitý strom závislostí a&nbsp;je jednodušší je vymockovat, než sestavit jejich závislosti.</li>
</ul>
<h2 id="nededim-od-sebe-testy"><a class="anchor" href="#nededim-od-sebe-testy" aria-hidden="true"><span class="anchor-icon">#</span></a>Nedědím od sebe testy</h2>
<p>Hlavní zásadu kterou dodržuji je, že testy od sebe nedědím. Mít <code>DatabaseTestCase</code>, <code>ApiTestCase</code> a&nbsp;podobně,
je zneužití dědičnosti a&nbsp;cesta k obrovské třídě plné kódu, z&nbsp;kterého každý potomek využívá jen nějaký (a vždy jiný)
subset.</p>
<p>Ideální by bylo, kdyby všechny testy dědily přímo od <code>TestCase</code>, který je ve frameworku. Avšak v&nbsp;praxi se mi osvědčilo
si pro testovanou aplikaci udělat <code>abstract MyTestCase</code> a&nbsp;všechno dědit od něj.</p>
<p>Důvody pro toto porušení jsou:</p>
<ul>
<li>Zapsání <code>Mockery::close()</code> do <code>tearDown()</code> ve společném předkovi jen jednou, aby se neopakoval v&nbsp;každém testu,
kde se na to navíc snadno zapomene.</li>
<li>Možnost clearovat globální stav na jednom místě, když pracuji s&nbsp;nějakou <em>legacy</em> codebase.
Například <code>Legacy_Class_Registry::clearStaticInMemoryCache()</code> a&nbsp;podobné perličky.</li>
</ul>
<p>A pak už být nekompromisní, žádná další vrstva dědičnosti. Takže test-třídy píši <code>final</code>.</p>
<h2 id="pojmenovavam-hodnoty-v-nbsp-data-providerech"><a class="anchor" href="#pojmenovavam-hodnoty-v-nbsp-data-providerech" aria-hidden="true"><span class="anchor-icon">#</span></a>Pojmenovávám hodnoty v&nbsp;Data Providerech</h2>
<p>Zvyšuje čitelnost a&nbsp;zrychluje orientaci v&nbsp;kódu.</p>
<p><strong>Špatně</strong></p>
<pre><code class="language-php">public function getDataForXyzTest(): array
{
     return [
        [true, 7, true],
        [false, 3, false],
     ];
}</code></pre>
<p><strong>Správně</strong></p>
<pre><code class="language-php">private const USER_ONLINE = true;
private const USER_OFFLINE = false;

private const USER_ID_KAREL = 7;
private const USER_ID_FERDA = 3;

private const USER_ACTIVE = true;
private const USER_NOT_ACTIVE = false;

public function getDataForXyzTest(): array
{
     return [
        [self::USER_ONLINE, self::USER_ID_KAREL, self::USER_ACTIVE],
        [self::USER_OFFLINE, self::USER_ID_FERDA, self::USER_NOT_ACTIVE],
     ];
}</code></pre>
<h2 id="dependency-injection-container-vzdy-vytvarim-cerstvy-pro-kazdy-beh-scriptu"><a class="anchor" href="#dependency-injection-container-vzdy-vytvarim-cerstvy-pro-kazdy-beh-scriptu" aria-hidden="true"><span class="anchor-icon">#</span></a>Dependency Injection Container vždy vytvářím čerstvý pro každý běh scriptu</h2>
<p>Když test potřebuje container:</p>
<ul>
<li>každý jeden běh testu <strong>musí</strong> mít svou vlastní instanci containeru,</li>
<li>metoda <code>createContainer()</code> musí v&nbsp;testu vždy vrátit nově sestavený container,</li>
<li>container není nikdy v&nbsp;<code>$this-&gt;container</code> v&nbsp;<code>TestCase</code> třídě.
Když je náhodou potřeba (ale nemělo by), tak se předává argumentem metody.</li>
</ul>
<h2 id="zjisteni-aktualniho-data-nahody-a-nbsp-podobne-vzdy-predavam-jako-zavislost"><a class="anchor" href="#zjisteni-aktualniho-data-nahody-a-nbsp-podobne-vzdy-predavam-jako-zavislost" aria-hidden="true"><span class="anchor-icon">#</span></a>Zjištění aktuálního data, náhody, a&nbsp;podobně vždy předávám jako závislost</h2>
<p>V aplikačním kódu nepíši <code>new DateTime()</code>, <code>time()</code>, <code>NOW()</code>, <code>rand()</code>.
Získávání nějakého „globálního“ stavu vždy obstarává služba.
Příkladem může být <a href="https://github.com/damejidlo/datetime-factory">DateTimeFactory</a> nebo:</p>
<pre><code class="language-php">class RandomProvider
{
    public function rand(int $min, int $max): int
    {
        return mt_rand($min, $max);
    }
}</code></pre>
<p>V testech si pak tuto závislost namockuji a&nbsp;předám. V&nbsp;integračních testech upravím službu v&nbsp;DI Containeru:</p>
<pre><code class="language-php">/**
 * @dataProvider getDataForXyzTest
 */
public function testXyz(..., \DateTimeImmutable $subjectTime): void
{
    $container = $this-&gt;createContainer();
    $dateTimeFactory = Mockery::mock(DateTimeFactoryImmutable::class);
    $dateTimeFactory-&gt;shouldReceive('getNow')-&gt;andReturn($subjectTime);
    $container-&gt;removeService('dateTimeFactory');
    $container-&gt;addService('dateTimeFactory', $dateTimeFactory);
}</code></pre>
<p>Ušetří to pár vrásek, letní-zimní čas a&nbsp;další magické chyby v&nbsp;testech.</p>
<h2 id="nepouzivam-phpunit-kdyz-nemusim"><a class="anchor" href="#nepouzivam-phpunit-kdyz-nemusim" aria-hidden="true"><span class="anchor-icon">#</span></a>Nepoužívám PHPUnit, když nemusím</h2>
<p><a href="https://phpunit.de/">PHPUnit</a> má jednu výhodu: super integraci s&nbsp;<a href="https://www.jetbrains.com/phpstorm/">PHPStorm</a> IDE.
Ale jinak je to bolest.</p>
<ul>
<li><code>TestCase</code> třída má asi milión metod, které vůbec mít nemá a&nbsp;ve kterých se nikdo nevyzná.</li>
<li>Dobrým příkladem jsou asserty, které je zvykem (i&nbsp;když jsou statické) volat na <code>$this-&gt;assertXyz(...)</code>.</li>
<li>Mockování:
<ul>
<li>je ukecané,</li>
<li>mock-builder se zase volá z&nbsp;kontextu – <code>$this-&gt;getMockBuilder(...)</code>,</li>
<li>mocky defaultně nezakrývají metody, takže když zapomenu metodu nadefinovat, zavolá se původní.</li>
</ul></li>
<li>Samotný framework je hrozně složitý – když potřebuji zdebugovat nějaké divné chování, utápím se v&nbsp;tom.</li>
<li>Neumí paralelizaci out-of-the-box. Doporučuji podívat se na <a href="http://engineering.wayfair.com/2015/02/sweet-parallel-phpunit/">tento článek</a>.</li>
</ul>
<h2 id="kdyz-musim-pouzivat-phpunit"><a class="anchor" href="#kdyz-musim-pouzivat-phpunit" aria-hidden="true"><span class="anchor-icon">#</span></a>Když musím používat PHPUnit</h2>
<ul>
<li>Helpery si píši jako traity. Jsou <em>context-aware</em> a&nbsp;je <strong>mnohem</strong> lepší traitit než dědit.
Doporučuji přečíst si na toto téma <a href="https://qafoo.com/blog/092_using_traits_with_phpunit.html">článek</a>
od Kora Nordmanna.</li>
<li>Snažím se alespoň o to, abych mohl používat jiný mockovací framework (osobně fandím <a href="http://docs.mockery.io">Mockery</a>).</li>
</ul>
<h2 id="separuji-testy-podle-typu-a-paralelizuji"><a class="anchor" href="#separuji-testy-podle-typu-a-paralelizuji" aria-hidden="true"><span class="anchor-icon">#</span></a>Separuji testy podle typu a paralelizuji</h2>
<ul>
<li><strong>Každý jeden test spouštím ve vlastním procesu</strong>. Legacy kód často obsahuje špinavosti, které ovlivňují
globální stav aplikace, a&nbsp;zajistit 100% vyčištení kontextu po každém testu v&nbsp;<code>tearDown</code> za tu práci nestojí.</li>
<li>Snažím se <strong>paralelizovat už od prvního testu</strong>. I&nbsp;když v&nbsp;případě legacy kódu to bývá težké.
Čím víc se paralelizace odloží, tím těžší následně je. Následné hledání, kde na sobě testy závisí, je
hledání jehly v kupce sena.</li>
<li>Spouštím <strong>unit testy odděleně od <em>těch ostatních</em></strong>, které používají databázi a&nbsp;podobně.
Když failnou některé z&nbsp;unitových testů, tak ty <em>ostatní</em> už ani nespouštím.</li>
</ul>
<h2 id="drzim-strukturu-testu-tak-aby-kopirovala-kod-aplikace"><a class="anchor" href="#drzim-strukturu-testu-tak-aby-kopirovala-kod-aplikace" aria-hidden="true"><span class="anchor-icon">#</span></a>Držím strukturu testů tak, aby kopírovala kód aplikace</h2>
<p>Většinou se držím toho, aby:</p>
<ul>
<li><code>TestCase</code> třídy kopírovaly třídy v aplikaci (<code>src/A/B/Service.php</code> + <code>tests/A/B/ServiceTest.php</code>),</li>
<li><code>testXyz</code> metody kopírovaly metody v testované třídě,</li>
<li>adresářová struktura ve složce <code>tests</code> kopírovala strukturu aplikace,</li>
<li>stejně tak namespacy, ty však začínají root namespacem <code>Tests</code>.</li>
</ul>
<h2 id="pouzivam-phpstorm-ide"><a class="anchor" href="#pouzivam-phpstorm-ide" aria-hidden="true"><span class="anchor-icon">#</span></a>Používám PHPStorm IDE</h2>
<ul>
<li>PHPStorm má klávesovou zkraktu <code>[Ctrl]</code> + <code>[Shift]</code> + <code>[T]</code>
pro: <a href="https://www.jetbrains.com/help/phpstorm/2016.2/navigating-between-test-and-test-subject.html">Navigating Between Test and Test Subject</a>.</li>
</ul>
<h2 id="v-cem-nemam-jasno-kacirske-myslenky"><a class="anchor" href="#v-cem-nemam-jasno-kacirske-myslenky" aria-hidden="true"><span class="anchor-icon">#</span></a>V čem nemám jasno / kacířské myšlenky</h2>
<ul>
<li>Kdy používat pro assert konečného stavu snapshoty a&nbsp;kdy nikoliv? Jsou snapshoty vůbec dobrý nápad?</li>
<li>Pohrávám si s myšlenkou, že pro větší monolitické aplikace by každý modul aplikace měl mít svou vlastní
<code>tests</code> složku. V extrémním případě by každá třída měla test třídu hned vedle sebe.</li>
</ul>
<h2 id="zaverem"><a class="anchor" href="#zaverem" aria-hidden="true"><span class="anchor-icon">#</span></a>Závěrem</h2>
<p>Napadá vás nějaký dobrý practice, který jsem nezmínil? Napište mi sem do komentářů nebo mi ho <a href="https://twitter.com/Achse_">tweetněte</a>. Díky!</p>
<div class="text-right"><em>Článek vyšel také na <a href="https://petrhejna.org/">blogu</a> autora.</em></div>
                </div>
            </div>

            <br>

            <div class="intermezzo-smaller">
                <div class="container">

Deprecated: "{$post|similarPosts} Latte filter was deprecated and will be removed in Statie 3.0. Use {$post|relatedPosts} instead." in /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/packages/RelatedPosts/src/Latte/Filter/RelatedPostsFilter.php on line 38

Call Stack:
    0.0001     362888   1. {main}() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/bin/statie:0
    0.0003     371288   2. include_once('/home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/bin/statie.php') /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/bin/statie:4
    0.3133    7501304   3. Symfony\Component\Console\Application->run() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/bin/statie.php:43
    0.3220    7677016   4. Symfony\Component\Console\Application->doRun() /home/travis/build/pehapkari/pehapkari.cz/vendor/symfony/console/Application.php:125
    0.3223    7677016   5. Symfony\Component\Console\Application->doRunCommand() /home/travis/build/pehapkari/pehapkari.cz/vendor/symfony/console/Application.php:224
    0.3223    7677016   6. Symplify\Statie\Console\Command\GenerateCommand->run() /home/travis/build/pehapkari/pehapkari.cz/vendor/symfony/console/Application.php:888
    0.3234    7681744   7. Symplify\Statie\Console\Command\GenerateCommand->execute() /home/travis/build/pehapkari/pehapkari.cz/vendor/symfony/console/Command/Command.php:262
    0.3235    7681744   8. Symplify\Statie\Application\StatieApplication->run() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Console/Command/GenerateCommand.php:43
    0.3710    9101952   9. Symplify\Statie\Application\StatieApplication->processTemplates() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Application/StatieApplication.php:63
    0.3714    9112680  10. Symplify\Statie\Renderable\RenderableFilesProcessor->processFiles() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Application/StatieApplication.php:105
    0.8253    9983752  11. Symplify\Statie\Renderable\Latte\LatteFileDecorator->decorateFiles() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Renderable/RenderableFilesProcessor.php:64
  110.7969   13696176  12. Symplify\Statie\Renderable\Latte\LatteFileDecorator->decorateFile() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Renderable/Latte/LatteFileDecorator.php:48
  110.7970   13685280  13. Symplify\Statie\Renderable\Latte\LatteFileDecorator->renderToString() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Renderable/Latte/LatteFileDecorator.php:79
  110.7970   13685336  14. Symplify\Statie\FlatWhite\Latte\LatteRenderer->renderExcludingHighlightBlocks() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/src/Renderable/Latte/LatteFileDecorator.php:127
  110.7973   13725296  15. Latte\Engine->renderToString() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/packages/FlatWhite/src/Latte/LatteRenderer.php:68
  110.8894   13956936  16. Templated7a2c7ecd5->capture() /home/travis/build/pehapkari/pehapkari.cz/vendor/latte/latte/src/Latte/Engine.php:81
  110.8894   13974256  17. Templated7a2c7ecd5->render() /home/travis/build/pehapkari/pehapkari.cz/vendor/latte/latte/src/Latte/Runtime/Template.php:326
  110.8896   13983256  18. Templatefbb92eba61->render() /home/travis/build/pehapkari/pehapkari.cz/vendor/latte/latte/src/Latte/Runtime/Template.php:176
  110.8896   13983736  19. Templatefbb92eba61->main() /home/travis/build/pehapkari/pehapkari.cz/vendor/latte/latte/src/Latte/Runtime/Template.php:198
  110.8902   14013528  20. Templatefbb92eba61->renderBlock() /tmp/_flat_white_latte_factory_cache/fbb92eba61.php:89
  110.8902   14013528  21. Templatefbb92eba61->blockRelatedPosts() /home/travis/build/pehapkari/pehapkari.cz/vendor/latte/latte/src/Latte/Runtime/Template.php:282
  110.8903   14013552  22. Symplify\Statie\RelatedPosts\Latte\Filter\RelatedPostsFilter->Symplify\Statie\RelatedPosts\Latte\Filter\{closure}() /tmp/_flat_white_latte_factory_cache/fbb92eba61.php:169
  110.8903   14013552  23. trigger_error() /home/travis/build/pehapkari/pehapkari.cz/vendor/symplify/statie/packages/RelatedPosts/src/Latte/Filter/RelatedPostsFilter.php:38


                </div>
            </div>

            <div class="container">
<div id="disqus_thread"></div>

<script type="text/javascript">
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//' + "pehapkari" + '.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
            </div>

            <br>
        </div>

        <script src="/assets/prism/prism.js"></script>
        <script id="dsq-count-scr" src="https://pehapkari.disqus.com/count.js" async defer></script>

<script>
    ga=function(){ ga.q.push(arguments) };
    ga.q=[];
    ga.l=+new Date;
    ga('create', "UA-89860072-1", 'auto');
    ga('send','pageview');
</script>
<script async defer src="https://www.google-analytics.com/analytics.js"></script>
<script>
    !function(f,b,e,v,n,t,s){ if(f.fbq)return;n=f.fbq=function(){ n.callMethod?
n.callMethod.apply(n,arguments):n.queue.push(arguments)};if(!f._fbq)f._fbq=n;
n.push=n;n.loaded=!0;n.version='2.0';n.queue=[];t=b.createElement(e);t.async=!0;
t.src=v;s=b.getElementsByTagName(e)[0];s.parentNode.insertBefore(t,s)}(window,
            document,'script','https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', "201338863559186");
    fbq('track', 'PageView');
</script>
    </body>
</html>


    <meta property="og:type" content="article">
    <meta property="og:title" content="Testování PHP kódu">
    <meta property="og:description" content="Testování aplikací není vždy tak snadné, jak se na papíře jeví. Svojí zkušeností jsem dospěl k&amp;nbsp;několika zásadám a&amp;nbsp;postupům, které se mi osvědčily a&amp;nbsp;které se tu pokusím sepsat a&amp;nbsp;částečně i&amp;nbsp;zdůvodnit. Pomáhají mi k&amp;nbsp;psaní čítelnějších a&amp;nbsp;udržovatelnějších testů. Za hlavní přínos pak považuji snadnou rozšiřitelnost testů, jejíž potřeba přichází s&amp;nbsp;rozšiřováním fukcionality projektu.">
    <meta property="og:url" content="https://pehapkari.cz/blog/2016/12/30/testovani-php-kodu/">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Testování PHP kódu">
    <meta name="twitter:description" content="Testování aplikací není vždy tak snadné, jak se na papíře jeví. Svojí zkušeností jsem dospěl k&amp;nbsp;několika zásadám a&amp;nbsp;postupům, které se mi osvědčily a&amp;nbsp;které se tu pokusím sepsat a&amp;nbsp;částečně i&amp;nbsp;zdůvodnit. Pomáhají mi k&amp;nbsp;psaní čítelnějších a&amp;nbsp;udržovatelnějších testů. Za hlavní přínos pak považuji snadnou rozšiřitelnost testů, jejíž potřeba přichází s&amp;nbsp;rozšiřováním fukcionality projektu.">


    <link href="/assets/prism/prism.css" rel="stylesheet" type="text/css">


